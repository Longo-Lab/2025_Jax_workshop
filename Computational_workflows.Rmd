---
title: "Computational Workflows for Single Cell and Spatial Transcriptomics"
author: "Robert R Butler III, Ph.D."
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    fig_width: 10
    fig_align: center
---

```{r, load_up, include = FALSE}
# knitr options
knitr::opts_chunk$set(
  error = TRUE # do not interrupt in case of errors
)

# packages to load
library(Seurat) # uses presto, MAST, and DESeq2
library(ggplot2)
library(data.table)
library(future) # should be installed by Seurat
library(Giotto)
library(patchwork)
library(RobustRankAggreg)
library(limma)
# library(liana)

```
# Introductory concepts (lecture)


# Single-cell analysis (interactive)
To begin, this course assumes you have a basic familiarity with single-cell analysis using the [Seurat](https://satijalab.org/seurat/) package. We won't cover in huge detail the major steps in a single-cell analysis, but leave it for you to explore. Our key steps:

1. Clean the data (not included) - see tools like SoupX, DoubletFinder, etc
2. (Optional) Integrate datasets, if multiple
3. Normalize & Scale
4. Calculate Principal Components
5. Find Neighbors
6. Find Clusters
7. Run UMAP

## Prep the (cleaned) data
This will define standard settings you intend to run for the analysis
```{r, get_sc_data}
sc <- readRDS("SEAAD_MTG_RNAseq_final-nuclei.2k_demo.rds")
# sc <- pbmc_small

# do you have multiple conditions to integrate?
integ <- TRUE
# what column name contains the groups you are integrating?
g_col <- 'Group' 
# how many principal components do you wish to use?
pcs <- 30
# what clustering resolution? 
resi <- 0.8

```

## Clean and Analyze
The bulk of the processing can be done in rapid succession, with linking `%>%` chains.
```{r, sc_process, message = FALSE, warning = FALSE}
if (integ) {
  # split by group column
  sc[["RNA"]] <- split(sc[["RNA"]], f = sc@meta.data[[g_col]])

  # Prep & PCA on each group
  sc %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData(vars.to.regress = c("Donor.ID")) %>%
    RunPCA(npcs = pcs) %>%
    RunUMAP(dims = 1:pcs, reduction.name = "umap") %>%

    # feature selection and integration prep
    IntegrateLayers(
      method = HarmonyIntegration,
      new.reduction = "harmony",
      verbose = TRUE
    ) %>%
    RunUMAP(
      dims = 1:pcs, 
      reduction = "harmony", 
      reduction.name = "umap.harmony"
    ) %>%
    FindNeighbors(reduction = "harmony", dims = 1:pcs) %>%
    FindClusters(resolution = resi) %>%

    # combine again
    JoinLayers() -> sc

} else { # otherwise, ignore integration
  sc %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData(vars.to.regress = c("Donor.ID")) %>%
    RunPCA(npcs = pcs) %>%
    FindNeighbors(dims = 1:pcs) %>%
    FindClusters() %>%
    RunUMAP(dims = 1:pcs) -> sc
} 

# # Save progress
# saveRDS(sc, file = "SEAAD_MTG_RNAseq_final-nuclei.2k_demo.rds")
# sc <- readRDS("SEAAD_MTG_RNAseq_final-nuclei.2k_demo.rds")

```

How did that integration turn out? We can visualize with the two UMAPs if we did integration, or just plotting the standard UMAP if we did not.
```{r, integ_plot}
if (integ) {
  p1 <- DimPlot(sc, reduction = "umap", group.by = "Donor.ID", shuffle = TRUE)
  p2 <- DimPlot(sc, reduction = "umap.harmony", group.by = "Donor.ID", shuffle = TRUE)
  p1 + p2 + plot_layout(guides = 'collect')
} else {
  DimPlot(sc, reduction = "umap", group.by = "Donor.ID", shuffle = TRUE)
}
```
Generally, not a lot of improvement, the sequencing pipeline the Allen Inst. used seemed to be pretty consistent across donors.

## Cell type annotations (maybe link MapMyCells)
Cell type identification is a class unto itself. Usually good methods involve a mix of automated cell type predictions, followed by careful curation to:

1. Verify cell type predictions & consolidate them across clusters
2. Eliminate heterotypic doublets & low quality cells
3. Subcluster and define population subtypes.

One useful tool for lightweight annotation prediction is the [MapMyCells](https://knowledge.brain-map.org/mapmycells/process) web server. In our case, we already have expertly curated cell types, defined by the XXXXXX column, as well as our experimental phenotype XXXXXX
```{r, annot_plot}
# Selecting your umap to plot
if (integ) {
  red <- "umap.harmony"
} else {
  red <- "umap"
}

# plots by functional annotation
p1 <- DimPlot(sc, reduction = red, group.by = "Subclass", label = TRUE, repel = TRUE) + 
  ggtitle("clusters") + 
  NoLegend() +
  theme(plot.title = element_text(hjust = 0.5))
p2 <- DimPlot(sc, reduction = red, group.by = g_col, shuffle = TRUE) +
    theme(legend.position = 'inside', legend.position.inside = c(0.6, 0.95))

p1 + p2

```

## Differential expression 
Now that we have data, we can use Seurat's built in [tools](https://satijalab.org/seurat/articles/de_vignette) to examine AD vs control differences. Notably, there are multiple methods for testing, with various options. Tools like MAST have some more stringent tests that also allow for inclusion of latent variables to correct for. Confounding variables like "Donor.ID" or "Sex" can impact your results! 

For now, we are going for speed, running the standard Wilcoxon Rank Sum test (sped up with [presto](https://github.com/immunogenomics/presto)) using an lapply call to run each cell type in a list. We can then use data.table to stack them up and do fast operations on them like count the totals of DE genes (p_val_adjust < 0.05):
```{r, sc_de}
# which column contains cell types?
ctype <- 'Subclass'
# which column contains experimental groups?
group <- 'Cognitive.Status'

# standard DE analysis --------------------------------------------------------
Idents(sc) <- ctype
# running in a lapply loop to test each cell type (future.lapply can be even faster) 
de <- lapply(levels(sc), function(i) {
  data.table(
    FindMarkers(sc,
      ident.1 = 'Dementia',
      ident.2 = 'No dementia',
      group.by = group,
      subset.ident = i,
      # test.use = "MAST", # more stringent test, also allows the use of latent.vars
      # latent.vars = c("Donor.ID", "Sex", "Age.at.Death"),
      max.cells.per.ident = 1000
    ),
    keep.rownames = TRUE
  )
})
# Using data.table allows us to quickly/safely combine our de results into one table 
setattr(de, 'names', levels(sc))
de <- rbindlist(de, idcol = ctype)
setnames(de, "rn", "Symbol")

# How many DE genes do we have?
de[p_val_adj < 0.05, .N, by = Subclass]

# # Let's save it
# fwrite(de, file = "SEAAD_MTG_RNAseq_final-nuclei.2k_demo.ad_vs_ctrl.txt.gz")
# de <- fread("SEAAD_MTG_RNAseq_final-nuclei.2k_demo.ad_vs_ctrl.txt.gz")

```

However, when doing differential expression it is important to consider that testing thousands of cells can inflate estimates of significance. Do you have a highly significant change with an `avg_log2FC` of 0.10 in less than 10% of your cell type (`pct.1` and `pct.2`). That may not reflect biologically relevant variability. In general you can limit this with certain options like limiting `max.cells.per.ident` for your comparisons. 

The [most robust](https://satijalab.org/seurat/articles/de_vignette#perform-de-analysis-after-pseudobulking) method is to construct pseudo-bulk datasets for a bulkRNAseq style measure with DESeq2. However, this can be an issue if you have few samples per group. In our case even with n == 6 per group there are only two DE genes in any cells...
```{r, sc_de_pseudo}
# # using pseudobulk analysis to control for within-sample correlation -----------
# pseudo <- AggregateExpression(sc, 
#   assays = "RNA",
#   return.seurat = TRUE, 
#   group.by = c("Donor.ID", group, ctype)
# )
# pseudo@assays$RNA$counts <- round(pseudo@assays$RNA$counts)
# 
# # add in some meta.data from the overall plot
# meta <- unique(data.table(sc@meta.data[, c("Donor.ID", "Sex", "Age.at.Death")]))
# # map
# Idents(pseudo) <- "Donor.ID"
# pseudo[["Sex"]] <- plyr::mapvalues(
#   x = pseudo@active.ident,
#   from = meta[["Donor.ID"]],
#   to = meta[["Sex"]]
# )
# pseudo[["Age.at.Death"]] <- plyr::mapvalues(
#   x = pseudo@active.ident,
#   from = meta[["Donor.ID"]],
#   to = meta[["Age.at.Death"]]
# )
# 
# Idents(pseudo) <- ctype
# # running in a lapply loop to test each cell type (future.lapply can be even faster) 
# de <- lapply(levels(pseudo), function(i) {
#   data.table(
#     FindMarkers(pseudo,
#       ident.1 = 'Dementia',
#       ident.2 = 'No dementia',
#       group.by = group,
#       subset.ident = i,
#       latent.vars = c("Sex", "Age.at.Death"),
#       test.use = "DESeq2"
#     ),
#     keep.rownames = TRUE
#   )
# })
# # Using data.table allows us to quickly/safely combine our de results into one table 
# setattr(de, 'names', levels(pseudo))
# de <- rbindlist(de, idcol = ctype)
# setnames(de, "rn", "Symbol")
# 
# # How many DE genes do we have?
# de[p_val_adj < 0.05, .N, by = Subclass]

```

In the end, lets see what we got with some pictures
```{r, volcanoes}
# Add a significant column with a nested ifelse
de[, sig := ifelse(
  test = avg_log2FC < -0.5 & p_val_adj < 0.05, 
  yes = "down", 
  no = ifelse(
    test = avg_log2FC > 0.5 & p_val_adj < 0.05, 
    yes = "up", 
    no = "ns"
  )
)]

# Add color, size and alpha (transparency) to volcano plot --------------------
cols <- c("up" = "#ffad73", "down" = "#26b3ff", "ns" = "grey") 
sizes <- c("up" = 1, "down" = 1, "ns" = 0.5) 
alphas <- c("up" = 1, "down" = 1, "ns" = 0.5)

# we need to plot each cell type, so we again use an lapply function for each Subclass
plist <- lapply(sort(unique(de$Subclass)), function(i) {
  ggplot(de[Subclass == i], 
    aes(x = avg_log2FC, y = -log10(p_val_adj), fill = sig, size = sig, alpha = sig)
  ) + 
    geom_point(shape = 21, color = "black") + 
    geom_hline(yintercept = -log10(0.05), linetype = "dashed") + 
    geom_vline(xintercept = c(-0.5, 0.5), linetype = "dashed") +
    scale_fill_manual(values = cols) + # Modify point color
    scale_size_manual(values = sizes) + # Modify point size
    scale_alpha_manual(values = alphas) + # Modify point transparency
    scale_x_continuous(
      breaks = c(seq(-8, 8, 2)),       
      limits = c(-8, 8)
    ) +
    ggtitle(i) + theme_classic() +
    theme(
      text = element_text(size = 5),
      plot.title = element_text(hjust = 0.5), 
      legend.position = 'none'
    )
})

# stick them all together 
wrap_plots(plist) + plot_layout(guides = 'collect')

```


# Introduction spatial (lecture) (from Sue)
Maybe just link to the broader [introduction](https://smcclatchy.github.io/spatial-transcriptomics/introduction.html) page?

Spatial data of either type can be evaluated in four conceptual frameworks (so far):
![Insert diagram]() 

1. Spatial features - is a gene more highly in a specific spatial region?
2. Cell-cell proximity - once identified, do cell types occur more closely to one another?
3. Interaction changed features - in those cells, does gene expression change based on proximity?
4. Ligand-receptor interaction - proximity expression, but tested for ligand-receptor pairs in source-target cell types.

More types of analysis are still developing, and the space can be described as 


# Spatial analysis (interactive)
Part of the reason we chose the SEA-AD dataset as a reference, is because we can work on the same Donor samples across multiple technologies. The Allen Inst. included MERFISH data for the same region, MTG, for many participants, including our twelve folks. That way, we can do some compare/contrasting of the two datasets. 


## Set up the data
As with before, there are some global settings to include, and lets load things into memory.
```{r, init_giotto}
# lets save some space in memory
remove(sc)
gc()


# define some global parameters (should still be similar to above)
# do you have multiple conditions to integrate?
integ <- TRUE
# what column name contains the groups you are integrating?
g_col <- 'Donor ID' 
# donors <- c("H21.33.015", "H21.33.028", "H21.33.023", "H21.33.014", "H21.33.031", "H20.33.015")
donors <- c("H20.33.035", "H21.33.023", "H20.33.012", "H20.33.040", "H20.33.004", "H21.33.031")
status <- factor(c(rep("ctrl", 3), rep("ad", 3)), levels = c('ctrl', 'ad'))
# how many principal components do you wish to use?
pcs <- 8
# what clustering resolution? 
resi <- 0.4


# lets load in our giotto datasets
set_giotto_python_path()
gobj <- loadGiotto("SEAAD_MTG_MERFISH.2024-12-11.giotto_obj")

```


## Check-in
So we can examine the Giotto object in detail, it is based on the [terra](https://rspatial.github.io/terra/index.html) spatial data package, and makes for objects that can store many different [types](https://drieslab.github.io/Giotto_website/articles/structure.html#giotto-object-structure) of information:

```{r, update_giotto}
# what am i?
gobj

# Giotto objects have instructions that save default settings
instructions(gobj)

# Lets update those
instructions(gobj, 
  param = c("save_dir", "save_plot", "return_plot")
) <- list(getwd(), FALSE, TRUE)

```
Another potential benefit is that certain spatial technologies allow exact RNA positioning, and immunostained images to be underlayed behind your cell labels, for very cool images at real sub-cellular resolution!
```{r, test_picture}
g <- GiottoData::loadGiottoMini("cosmx", verbose = FALSE)
spatInSituPlotPoints(g, 
  show_image = TRUE, 
  image_name = c("fov002-composite", "fov003-composite"),
  feats = list(fDataDT(g)[, feat_ID]),
  point_size = 0.25,
  show_legend = FALSE,
  polygon_color = 'white'
)


```
Sadly, our MERFISH data will limit rna counts to the cell level, where each point is a cell with ~ 180 gene expression values.

Rather than use all 12 donors for this example, we have the three most normal and three highest `Overall AD neuropathological change`. To get these from the overall dataset takes some work, but for now lets examine how they look in space. Prompt: Do you see any notable spatial features?  
```{r, init_spatplot}
p <- spatPlot(gobj, 
  cell_color = "Subclass",
  point_size = 1,
  cell_color_code = as.vector(palette.colors(n = 24, palette = "Alphabet"))
)
p + labs(subtitle = paste(donors, collapse = "       ")) + 
  theme(legend.position = 'bottom', plot.subtitle = element_text(hjust = 0.5))

```
Each of these blocks represents a section through the cortex, from L1 --> white matter at the bottom.
Layers of neurons tend to be easily recognized transcriptomically, and this has been the case across multiple datasets (Yao 2021, Yao 2024, Lots more can be included). This actually extends to brain regions as well, as the Allen Institute's recent series of papers (Yao 2024, Merscope paper 2024). This can make it sort of easy to compare Layers between single-cell RNAseq and spatial RNAseq, though there is no replacement for the actual spatial information.

Bonus: How would I identify the `Donor ID` if I was trying to look at it?


## Remember our steps
Thinking back to the single-cell data, there were a series of steps:

1. Clean the data (not included) - see tools like SoupX, DoubletFinder, etc
2. ~~(Optional) Integrate datasets, if multiple~~
3. Normalize & Scale
4. Calculate Principal Components
5. Find Neighbors
6. Find Clusters
7. Run UMAP

Do those still apply for spatial data? 

For the most part, excepting that we are analyzing the ad and ctrl data separately, so there is no integration step. We also can actually use spatial information in our Neighbors/Clusters step to make our clustering more constrained to spatial zones.


## Clean and prep
This data has already been cleaned/filtered a fair bit by the SEA-AD group, but for informational purposes, lets look first at what a giotto object is and then filter/normalize  
```{r, spat_filter_norm}
gobj %>% 
  # filter out cells with too few features, or features in too few cells
  filterGiotto(feat_det_in_min_cells = 5, min_det_feats_per_cell = 5) %>%
  # normalize using scale factor (depends on the technology)
  normalizeGiotto(scalefactor = 10000, verbose = TRUE) %>%
  # calculate feature and cell statistics on normalized data
  addStatistics(expression_values = "normalized") %>%
  # with MERSCOPE there are very few genes, so we specify highly variable features to use
  calculateHVF(method = "var_p_resid", var_number = 120, show_plot = TRUE) -> gobj

```

Now that our normalized data is ready, lets make some clusters in the spatial style. A notable difference with other platforms like CosMx/Xenium/scRNAseq is that there are few total genes. So automated selection of variable genes for principal components doesn't work. We can specify a theshold using `calculateHVF`. We also need to integrate our **all** of our sample slides using Harmony.
```{r, spat_cluster}
gobj %>% 
  runPCA() %>%
  # screePlot() %>% # with this few genes, 8 pcs is sufficient
  runGiottoHarmony(
    vars_use = g_col,
    dimensions_to_use = 1:pcs,
  ) %>%
  runUMAP(
    dim_reduction_name = "harmony", 
    dim_reduction_to_use = "harmony",
    name = "umap_harmony",
    dimensions_to_use = 1:pcs) -> gobj

```

When clustering with spatial data, we can actually incorporate spatial information in those clusters. Leiden clustering makes use of a spatial nearest neighbor network when clustering cells. The [workshop](https://drieslab.github.io/giotto_workshop_2024/working-with-multiple-samples.html#analyzing-joined-objects) from the Giotto group actually shows what happens if you don't integrate your datasets with two slides, the major groupings are actually the slides themselves! 
```{r, spat_network}
gobj %>%
  # Create a sNN network (default)
  createNearestNetwork(dimensions_to_use = 1:pcs, k = 15) %>%
  # Perform clustering
  doLeidenCluster(resolution = resi, name = paste0("leiden_", resi)) -> gobj

# Plot the clusters upon the UMAP
p1 <- plotUMAP(gobj, 
  cell_color = paste0("leiden_", resi),
  title = paste0("leiden_", resi),
  point_size = 1,
  dim_reduction_name = "umap_harmony",
  show_NN_network = TRUE,
  show_legend = FALSE,
  cell_color_code = as.vector(palette.colors(n = 24, palette = "Alphabet"))
)

# Plot the Subclasses upon the UMAP
p2 <- plotUMAP(gobj, 
  cell_color = "Subclass",
  title = "Subclass",
  point_size = 1,
  dim_reduction_name = "umap_harmony",
  show_NN_network = TRUE,
  show_legend = FALSE,
  cell_color_code = as.vector(palette.colors(n = 24, palette = "Alphabet"))
)

# plot together
p1 + p2

```


Additionally, Leiden clustering in Giotto has the ability to `doLeidenSubCluster` on individual clusters to more finely split them up without changing the overall cluster resolution. This can allow you to subdivide more heterogeneous populations dynamically as needed. Looking at the SEA-AD annotations, several groups (like GABAergic neuron subtypes Pvalb, Sst, etc) could be further split into subtypes. 


But for now, we can also see how the automated clustering did across the different slides:
```{r, leid_spatplot}
p <- spatPlot(gobj, 
  cell_color = paste0("leiden_", resi),
  point_size = 1,
  cell_color_code = as.vector(palette.colors(n = 24, palette = "Alphabet"))
)
p + labs(subtitle = paste(donors, collapse = "       ")) + 
  theme(legend.position = 'bottom', plot.subtitle = element_text(hjust = 0.5))

```
Notably the `beige` and `copper` colored clusters that are L2/3 IT neurons are in the correct layer. The light gray set that is L4 IT neurons are a little harder to see in the picture, but are in the middle.

From this point on, we can also save the Giotto objects, as we won't be modifying it anymore, just analyzing it.
```{r, save_giotto}
saveGiotto(gobj,
  foldername = "SEAAD_MTG_MERFISH.2024-12-11.giotto_obj",
  method = 'qs',
  overwrite = TRUE
)

```

## Cell type annotations
The dataset already has well characterized cell types included, but let us take a look at the standard workflow for marker genes for identifying clusters.  
```{r, spat_annots}
# find gini markers (can also use scran or Mast)
markers_gini <- findMarkers_one_vs_all(gobj,
  method = "gini",
  cluster_column = paste0("leiden_", resi),
  min_feats = 10
)

# select genes for cluster heatmap
top_gini <- markers_gini[!feats %like% "Blank", head(.SD, 6), by = "cluster"]

p <- plotMetaDataHeatmap(gobj,
  selected_feats = unique(top_gini$feats),
  custom_feat_order = unique(top_gini$feats),
  custom_cluster_order = unique(top_gini$cluster),
  metadata_cols = paste0("leiden_", resi), 
  x_text_size = 8, 
  y_text_size = 4
)
p

```

## Spatial genes
Up until now, we have been able to look at the combined set of all slides. However, in order to understand spatial relationships it is more useful to examine each slide individually and then meta-analyze them. Otherwise we can encounter a similar problem to snRNAseq, where tens of thousands of observations overwhelm significance. Additionally, spatial relationships are going to be scored differently in joined images of multiple slides versus in isolation. So to handle this lets split them up into a list of gobjs.
```{r, split_slides}
gobjs <- splitGiotto(gobj, by = g_col)

# We have to create a spatial network for each slide based on physical distance of cell centroids
gobjs <- lapply(gobjs, createSpatialNetwork)

# example of a spatial networks (small window)
smallfov <- subsetGiottoLocs(gobjs[[1]],
    x_max = 500,
    x_min = 0,
    y_max = 3000,
    y_min = 2000
)

spatPlot(smallfov, 
  show_network = TRUE,
  network_color = "blue",
  point_size = 1, 
  cell_color = "Subclass",
  show_plot = TRUE
)

```

If you don't have multiple images per group, you can rely on the default output for the single image, you will simply not have the extra layer of statistical confidence on between group differences.

Now we can find spatially organized gene expression by examining the binarized expression of cells and their spatial neighbors. The full description is [here](https://drieslab.github.io/Giotto_website/reference/binSpect.html) 
```{r, spat_genes}
# identify spatial genes
spat_feats <- lapply(gobjs, binSpect)
spat_feats <- rbindlist(spat_feats, idcol = g_col)
spat_feats <- spat_feats[!feats %like% "Blank"]
# fwrite(spat_feats, file = "SEAAD_MTG_MERFISH.2024-12-11.spat_feats_raw.txt.gz")
# spat_feats <- fread("SEAAD_MTG_MERFISH.2024-12-11.spat_feats_raw.txt.gz")

spat_feats
```
Key values in this analysis are the `score`, `av_expr`, `high_expr`:
- `score`: `estimate * -log(p.value)`, the measure of the "spatialness of the gene"
- `av_expr`: the average expression high-expressing genes
- `high_expr`: the total number of high expressing genes

So a simple solution is to simply look at the top ranked spatial genes, these genes have some manner of spatial grouping where the gene is most expressed, and is great for exploring tissue heterogeneity. The first, as a rank order, can be combined using `RobustRankAgg` for each of our experimental groups. The second we want to test for a difference between ad and control groups.

```{r, spat_feats_rank}
# first, lets calculate the rank aggregate spatial score for each `status`
agg <- merge(
  x = aggregateRanks(
    lapply(donors[status == 'ad'], function(i) {
      spat_feats[order(-score)][`Donor ID` == i, feats]
    })
  ),
  y = aggregateRanks(
    lapply(donors[status == 'ctrl'], function(i) {
      spat_feats[order(-score)][`Donor ID` == i, feats]
    })
  ),
  by = 'Name',
  suffixes = c('.ad', '.ctrl')
)
setorder(agg, Score.ad, Score.ctrl)
agg

# plot the top aggregate score for ad
top <- agg[1, "Name"]
p_list <- lapply(names(gobjs), function(i) {
  p <- spatFeatPlot2D(gobjs[[i]],
    expression_values = "scaled", 
    feats = top,
    point_shape = "border", 
    point_border_stroke = 0.1,
    show_network = FALSE, 
    network_color = "lightgrey", 
    point_size = 1,
    scale_alpha_with_expression = TRUE,
    cow_n_col = 1,
    save_plot = FALSE,
    return_plot = TRUE
  ) 
  p + scale_color_distiller(name = "RdBu", limits = c(-3, 3)) + ggtitle(paste(i, top))
})
wrap_plots(p_list) + gt::gt(de[Symbol == top][order(p_val_adj)]) + plot_layout(nrow = 2, guides = 'collect')


```
So the top gene is pretty highly expressed in the L2/3 layer, regardless of disease status. Even more apparent when you pop it out in a new viewer window. In fact, it appears most spatial genes have similar agg ranks in either case, which you might expect from a very layered tissue like the cortex.

Now let's look at the top changing genes across the two conditions. We can use a standard DE package that can handle log transformed values like `limma`.
```{r, spat_feats_de}
# to test differences in average expression in high cells, use limma's lmFit ---
# make a table of the av_expr for each Donor
exp <- data.frame(
  dcast(spat_feats, feats ~ `Donor ID`, value.var = 'av_expr'), 
  row.names = 'feats'
)

# reorder and set the disease status for limma
exp <- exp[, donors]
design <- model.matrix(~status)

# sample level ad vs ctrl
spat_lm <- as.data.table(
  topTable(eBayes(lmFit(exp, design)), number = nrow(exp)), 
  keep.rownames = "feats"
) 

# merge with aggregate spatial scores
spat_lm <- merge(spat_lm, agg, by.x = 'feats', by.y = 'Name')
setorder(spat_lm, adj.P.Val, P.Value)
# fwrite(spat_feats, file = "SEAAD_MTG_MERFISH.2024-12-11.spat_feats_agg.txt.gz")
# spat_feats <- fread("SEAAD_MTG_MERFISH.2024-12-11.spat_feats_agg.txt.gz")

spat_lm

# plot the top score changes between groups
top <- spat_lm[3, feats]
p_list <- lapply(names(gobjs), function(i) {
  p <- spatFeatPlot2D(gobjs[[i]],
    expression_values = "scaled", 
    feats = top,
    point_shape = "border", 
    point_border_stroke = 0.1,
    show_network = FALSE, 
    network_color = "lightgrey", 
    point_size = 1,
    scale_alpha_with_expression = TRUE,
    cow_n_col = 1,
    save_plot = FALSE,
    return_plot = TRUE
  )
  p + scale_color_distiller(name = "RdBu", limits = c(-3, 3)) + ggtitle(paste(i, top))
})
wrap_plots(p_list) + gt::gt(de[Symbol == top][order(p_val_adj)]) + plot_layout(nrow = 2, guides = 'collect')

```
So notably, spatial genes can change in two ways:
1. The amount of "spatialness" of the gene
2. The level of expression within the spatial region

Similar to bulkRNAseq data, you can also create [co-expression modules](https://drieslab.github.io/Giotto_website/articles/spatial_coexpression_modules.html) of correlated spatial genes so see which have similar patterns, and develop metagenes analagous to eigengenes for each module. In cases like an organized brain though, these are likely to overlap with your existing cluster annotations. Lastly, you can use these spatial genes with a hidden markov random field (HMRF) model to segment cell clusters by [spatial domain](https://drieslab.github.io/Giotto_website/articles/hmrf.html) instead of traditional Leiden clustering.

Strictly speaking, there is a third spatial gene alteration to consider, which is that the spatial shape or size might change in a way that doesn't alter it's spatial rank, but that would be a much rarer and more challenging thing to identify without visual inspection...


## Cell proximity
So, on to the next plane of spatial information. Since we have cell types, we can define fairly easily which cells are next to one another. Are L2/3 IT neurons next to L4 IT neurons? Certainly a fair few are.

But what about the more mobile cell types like glia? Does that change with your condition?
```{r, spat_prox, fig.height=15}
cell_prox <- lapply(gobjs, cellProximityEnrichment, 
  cluster_column = "Subclass",
  adjust_method = "fdr"
)
# saveRDS(cell_prox, file = "SEAAD_MTG_MERFISH.2024-12-11.cell_prox_raw.rds")
# cell_prox <- readRDS("SEAAD_MTG_MERFISH.2024-12-11.cell_prox_raw.rds")

# barplot
p_list <- lapply(c(1, length(gobjs)), function(i) {
  cellProximityBarplot(gobjs[[i]],
    CPscore = cell_prox[[i]]
  ) 
})
wrap_plots(p_list) + plot_layout(guides = 'collect') + plot_annotation(tag_levels = list(levels(status)))

prox_tab <- lapply(cell_prox, function(i) i[[2]])
prox_tab <- rbindlist(prox_tab, idcol = g_col)


```
In this case, the same spatial network is used, but you are calculating the number of cell-cell pairings observed versus expected with permutations of random re-shuffling of the cell type labels.



## Interaction changed features
```{r, spat_icf}

## select top 25th highest expressing genes
gene_metadata <- fDataDT(SS_seqfish)

plot(gene_metadata$nr_cells, gene_metadata$mean_expr)

plot(gene_metadata$nr_cells, gene_metadata$mean_expr_det)

quantile(gene_metadata$mean_expr_det)

high_expressed_genes <- gene_metadata[mean_expr_det > 3.5]$feat_ID

## identify genes that are associated with proximity to other cell types
plan("multisession", workers = 6)

ICFsForesHighGenes <- findInteractionChangedFeats(
    gobject = SS_seqfish,
    selected_feats = high_expressed_genes,
    spatial_network_name = "Delaunay_network",
    cluster_column = "cell_types"
    diff_test = "permutation",
    adjust_method = "fdr",
    nr_permutations = 2000,
    do_parallel = TRUE
)

## visualize all genes
plotCellProximityFeats(SS_seqfish,
                       icfObject = ICFsForesHighGenes,
                       method = "dotplot")

## filter genes
ICFscoresFilt <- filterICF(ICFsForesHighGenes)

## visualize subset of interaction changed genes (ICFs)
ICF_genes <- c("Jakmip1", "Golgb1", "Dact2", "Ddx27", "Abl1", "Zswim8")
ICF_genes_types <- c("Lhx6 iNeuron", "Lhx6 iNeuron", "L4 eNeuron", "L4 eNeuron", "astrocytes", "astrocytes")
names(ICF_genes) <- ICF_genes_types

plotICF(gobject = SS_seqfish,
        icfObject = ICFsForesHighGenes,
        source_type = "endothelial",
        source_markers = c("Pltp", "Cldn5", "Apcdd1"),
        ICF_feats = ICF_genes
)
```

# Single-cell x Spatial analysis (interactive)
1.	Differential ligand-receptor analysis
2.	Differential spatial relationships
3.	(maybe) Correlation to TREAT-AD

# Conclusion concepts (lecture)
(Maybe with time) Future promising tools (lecture or demo, non-interactive)
## Spacia + downstream genes in target cell
## Multimodal integration tools
